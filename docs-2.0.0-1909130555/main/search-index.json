{
    "docs": [
        {
            "location": "/developer/06_debugging",
            "text": " To stop the local operator just use CTRL-Z or CTRL-C. Sometimes processes can be left around even after exiting in this way. To make sure all of the processes are dead you can run the kill script: <markup lang=\"bash\" >make debug-stop ",
            "title": "Stopping the Debug Session"
        },
        {
            "location": "/developer/06_debugging",
            "text": " To debug the operator while running a particular tests first start the debugger as described above. Then use the debug make test target to execute the test. For example to debug the TestMinimalCoherenceCluster test first start the debug session: <markup lang=\"bash\" >make run-debug Then execute the test with the debug-e2e-local-test make target: <markup lang=\"bash\" >make debug-e2e-local-test GO_TEST_FLAGS='-run=^TestMinimalCoherenceCluster$$' ",
            "title": "Debugging Tests"
        },
        {
            "location": "/developer/06_debugging",
            "text": " Assuming that you have an IDE capable of debugging Go and have delve installed you can debug the operator. When debugging an instance of the operator is run locally so functionality that will only work when the operator is deployed into k8s cannot be properly debugged. To start an instance of the operator that can be debugged use the make target run-debug , for example: <markup lang=\"bash\" >make run-debug This will start the operator and listen for a debugger to connect on the default delve port 2345 . The operator will connect to whichever k8s cluster the current environment is configured to point to. Stopping the Debug Session To stop the local operator just use CTRL-Z or CTRL-C. Sometimes processes can be left around even after exiting in this way. To make sure all of the processes are dead you can run the kill script: <markup lang=\"bash\" >make debug-stop Debugging Tests To debug the operator while running a particular tests first start the debugger as described above. Then use the debug make test target to execute the test. For example to debug the TestMinimalCoherenceCluster test first start the debug session: <markup lang=\"bash\" >make run-debug Then execute the test with the debug-e2e-local-test make target: <markup lang=\"bash\" >make debug-e2e-local-test GO_TEST_FLAGS='-run=^TestMinimalCoherenceCluster$$' ",
            "title": "Debugging the Coherence Operator"
        },
        {
            "location": "/guides/02_quickstart",
            "text": " TBD&#8230;&#8203; ",
            "title": "Quick Start Guide"
        },
        {
            "location": "/install/03_helm_install",
            "text": " The simplest way to install the Coherence Operator is to use the Helm chart. This will ensure that all of the correct resources are created in Kubernetes. ",
            "title": "preambule"
        },
        {
            "location": "/install/03_helm_install",
            "text": " Add the coherence helm repository using the following commands: <markup lang=\"bash\" >helm repo add coherence https://oracle.github.io/coherence-operator/charts helm repo update ",
            "title": "Add the Coherence Helm Repository"
        },
        {
            "location": "/install/03_helm_install",
            "text": " To uninstall the operator: <markup lang=\"bash\" >helm delete --purge coherence-operator ",
            "title": "Uninstall the Coherence Operator Helm chart"
        },
        {
            "location": "/install/03_helm_install",
            "text": " Once the Coherence Helm repo is configured the Coherence Operator can be installed using a normal Helm install command: <markup lang=\"bash\" >helm install \\ --namespace &lt;namespace&gt; \\ --name coherence-operator \\ coherence/coherence-operator where &lt;namespace&gt; is the namespace that the Coherence Operator will be installed into and the namespace where it will manage CoherenceClusters Uninstall the Coherence Operator Helm chart To uninstall the operator: <markup lang=\"bash\" >helm delete --purge coherence-operator ",
            "title": "Install the Coherence Operator Helm chart"
        },
        {
            "location": "/clusters/01_introduction",
            "text": " Creating a Coherence cluster using the Coherence Operator is as simple as creating any other Kubernetes resource. ",
            "title": "preambule"
        },
        {
            "location": "/clusters/01_introduction",
            "text": " The Coherence Operator uses a Kubernetes CustomResourceDefinition named t`CoherenceCluster` o define the spec for a Coherence cluster. All of the fields of the CoherenceCluster crd are optional so a Coherence cluster can be created with yaml as simple as the following: <markup lang=\"yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: my-cluster The metadata.name field will be used as the Coherence cluster name. The yaml above will create a Coherence cluster with three storage enabled members. There is not much that can actually be achived with this cluster because no ports are exposed outside of Kubernetes so the cluster is inaccessible. It could be accessed by other Pods in the same ",
            "title": "Create CoherenceCluster Resources"
        },
        {
            "location": "/clusters/01_introduction",
            "text": " When a CoherenceCluster is deployed into Kubernetes the Coherence Operator will create a number of other resources in Kubernetes. A CoherenceCluster is made up of one or more roles. In theory a CoherenceCluster could have zero roles but this would not by typical. A role maps to zero or more Pods that will all share the same specification and hence typically take on the same business role within an application. In Kubernetes a Coherence role is represented by a CoherenceRole and a CoherenceInternal crd although it is not expected that these crds are modified directly, they are purely used to allow roles in the same cluster to be managed as independent entities by the Coherence Operator. When a resource of type CoherenceCluster is created in Kubernetes the Coherence Operator will create the other resources. A Service will be created for every CoherenceCluster to be used for Coherence WKA (cluster membership discovery). Every Pod that is created as part of this cluster will have a label coherenceCluster=&lt;cluster-name&gt; and the WKA Service uses this label to identify all of the Pods in the same Coherence cluster. The Pods then use the Service as their WKA address. A CoherenceRole resource will be created for each role in the CoherenceCluster spec that has a replica count greater than zero. The name of the CoherenceRole will be in the form &lt;cluster-name&gt;-&lt;role-name&gt; Each CoherenceRole will have a related CoherenceInternal resource. The name of the CoherenceInternal will be the same as the CoherenceRole resource. Each CoherenceRole will have a related StatefulSet with corresponding Pods and headless Service required by the StatefulSet . The name of the StatefulSet will be the same as the CoherenceRole For each port that a role in a CoherenceCluster is configured to expose a corresponding Service will be created for that port. The name of the Service will be &lt;cluster-name&gt;-&lt;role-name&gt;-&lt;port-name&gt; (although this can be overridden when specifying the port in the CoherenceCLuster spec for that role and port). ",
            "title": "Kubernetes Resource Relationships When Creating Coherence Clusters"
        },
        {
            "location": "/clusters/01_introduction",
            "text": " A role is what is actually configured in the CoherenceCluster spec. In a traditional Coherence application that may have had a number of storage enabled members and a number of storage disable Coherence*Extend proxy members this cluster would have effectively had two roles, \"storage\" and \"proxy\". Some clusters may simply have just a storage role and some complex Coherence applications and clusters may have many roles and even different roles storage enabled for different caches/services within the same cluster. ",
            "title": "Coherence Roles"
        },
        {
            "location": "/install/05_pre_release_versions",
            "text": " Pre-release version of the Coherence Operator are made available from time to time. ",
            "title": "preambule"
        },
        {
            "location": "/install/05_pre_release_versions",
            "text": " Not all pre-release images are pushed to public repositories such as Docker Hub. Consequently when installing those versions of the Coherence Operator credentials and Kubernetes pull secrets will be required. For example to access an image in the iad.ocir.io/odx-stateservice repository you would need to have your own credentials for that repository so that a secret can be created. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; \\ create secret docker-registry coherence-operator-secret \\ --docker-server=$DOCKER_REPO \\ --docker-username=$DOCKER_USERNAME \\ --docker-password=$DOCKER_PASSWORD \\ --docker-email=$DOCKER_EMAIL Replace &lt;namespace&gt; with the Kubernetes namespace that the Coherence Operator will be installed into. In this example the name of the secret to be created is coherence-operator-secret Replace $DOCKER_REPO with the name of the Docker repository that the images are to be pulled from. Replace $DOCKER_USERNAME with your username for that repository. Replace $DOCKER_PASSWORD with your password for that repository. Replace $DOCKER_EMAIL with your email (or even a fake email). See the Kubernetes documentation on pull secrets for more details. Once a secret has been created in the namespace the Coherence Operator can be installed with an extra value parameter to specify the secret to use: <markup lang=\"bash\" >helm install coherence-unstable/coherence-operator \\ --version 2.0.0-1909130555 \\ --namespace &lt;namespace&gt; \\ --set imagePullSecrets=coherence-operator-secret \\ --name coherence-operator Set the pull secret to use to the same name that was created above. ",
            "title": "Accessing Pre-Release Coherence Operator Docker Images"
        },
        {
            "location": "/install/05_pre_release_versions",
            "text": " Pre-release versions of the Coherence Operator are not guaranteed to be bug free and should not be used for production use. Pre-release versions of the Helm chart and Docker images may be removed and hence made unavailable without notice. APIs and CRD specifications are not guaranteed to remain stable or backwards compatible between pre-release versions. To access pre-release versions of the Helm chart add the unstable chart repository. <markup lang=\"bash\" >helm repo add coherence-unstable https://oracle.github.io/coherence-operator/charts-unstable helm repo update To list all of the available Coherence Operator chart versions: <markup lang=\"bash\" >helm search coherence-operator -l The -l parameter shows all versions as opposed to just the latest versions if it was omitted. A specific pre-release version of the Helm chart can be installed using the --version argument, for example to use version 2.0.0-1909130555 : <markup lang=\"bash\" >helm install coherence-unstable/coherence-operator \\ --version 2.0.0-1909130555 \\ --namespace &lt;namespace&gt; \\ --name coherence-operator The --version argument is used to specify the exact version of the chart The optional --namespace parameter to specify which namespace to install the operator into, if omitted then Helm will install into whichever is currently the default namespace for your Kubernetes configuration. When using pre-release versions of the Helm chart it is always advisable to install a specific version otherwise Helm will try to work out the latest version in the pre-release repo and as pre-release version numbers are not strictly sem-ver compliant this may be unreliable. Accessing Pre-Release Coherence Operator Docker Images Not all pre-release images are pushed to public repositories such as Docker Hub. Consequently when installing those versions of the Coherence Operator credentials and Kubernetes pull secrets will be required. For example to access an image in the iad.ocir.io/odx-stateservice repository you would need to have your own credentials for that repository so that a secret can be created. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; \\ create secret docker-registry coherence-operator-secret \\ --docker-server=$DOCKER_REPO \\ --docker-username=$DOCKER_USERNAME \\ --docker-password=$DOCKER_PASSWORD \\ --docker-email=$DOCKER_EMAIL Replace &lt;namespace&gt; with the Kubernetes namespace that the Coherence Operator will be installed into. In this example the name of the secret to be created is coherence-operator-secret Replace $DOCKER_REPO with the name of the Docker repository that the images are to be pulled from. Replace $DOCKER_USERNAME with your username for that repository. Replace $DOCKER_PASSWORD with your password for that repository. Replace $DOCKER_EMAIL with your email (or even a fake email). See the Kubernetes documentation on pull secrets for more details. Once a secret has been created in the namespace the Coherence Operator can be installed with an extra value parameter to specify the secret to use: <markup lang=\"bash\" >helm install coherence-unstable/coherence-operator \\ --version 2.0.0-1909130555 \\ --namespace &lt;namespace&gt; \\ --set imagePullSecrets=coherence-operator-secret \\ --name coherence-operator Set the pull secret to use to the same name that was created above. ",
            "title": "Accessing Pre-Release Versions"
        },
        {
            "location": "/developer/03_high_level",
            "text": " The CoherenceCluster CRD is the main CRD that defines what a Coherence cluster looks like. This is the CRD that a customer creates and manges through the normal kubernetes commands and APIs. A CoherenceCluster is made up of one or more roles. Each role defines a sub-set of the members of a Coherence cluster (or all of the members in the case of a cluster with a single role). The yaml for the CoherenceCluster CRD is in the file deploy/crds/coherence_v1_coherencecluster_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceCluster struct in the pkg/apis/coherence/v1/coherencecluster_types.go source file. ",
            "title": "CoherenceCluster CRD"
        },
        {
            "location": "/developer/03_high_level",
            "text": " The CoherenceRole CRD is a definition of a role within a CoherenceCluster. A role is a sub-set of the members of a cluster that all share the same configuration. A customer should not interact directly with a CoherenceRole other than when scaling (for example using kubectl scale commands). The reason that a cluster is split into roles represented by a different CRD is to allow more fine grained control over different parts of the cluster, especially for operations such as scaling. By having a separate CRD for a role allows a customer to update or scale each role individually. The yaml for the CoherenceRole CRD is in the file deploy/crds/coherence_v1_coherencerole_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceRole struct in the pkg/apis/coherence/v1/coherencerole_types.go source file. ",
            "title": "CoherenceRole CRD"
        },
        {
            "location": "/developer/03_high_level",
            "text": " The CoherenceInternal CRD is (as the name suggests) entirely internal to the Coherence Operator and a customer should not interact with it at all. The CoherenceInternal CRD is a representation of the values file used to install the Coherence Helm chart. The yaml for the CoherenceInternal CRD is in the file deploy/crds/coherence_v1_coherenceinternal_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceInternal struct in the pkg/apis/coherence/v1/coherenceinternal_types.go source file. ",
            "title": "CoherenceInternal CRD"
        },
        {
            "location": "/developer/03_high_level",
            "text": " In Kubernetes a CRD is a yaml (or json) file that defines the structure of a custom resource. When building operators using the Operator SDK the yaml files are not edited directly, they are generated from the Go structs in the source code. The Coherence Operator has three CRDs: CoherenceCluster CoherenceRole CoherenceInternal CoherenceCluster CRD The CoherenceCluster CRD is the main CRD that defines what a Coherence cluster looks like. This is the CRD that a customer creates and manges through the normal kubernetes commands and APIs. A CoherenceCluster is made up of one or more roles. Each role defines a sub-set of the members of a Coherence cluster (or all of the members in the case of a cluster with a single role). The yaml for the CoherenceCluster CRD is in the file deploy/crds/coherence_v1_coherencecluster_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceCluster struct in the pkg/apis/coherence/v1/coherencecluster_types.go source file. CoherenceRole CRD The CoherenceRole CRD is a definition of a role within a CoherenceCluster. A role is a sub-set of the members of a cluster that all share the same configuration. A customer should not interact directly with a CoherenceRole other than when scaling (for example using kubectl scale commands). The reason that a cluster is split into roles represented by a different CRD is to allow more fine grained control over different parts of the cluster, especially for operations such as scaling. By having a separate CRD for a role allows a customer to update or scale each role individually. The yaml for the CoherenceRole CRD is in the file deploy/crds/coherence_v1_coherencerole_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceRole struct in the pkg/apis/coherence/v1/coherencerole_types.go source file. CoherenceInternal CRD The CoherenceInternal CRD is (as the name suggests) entirely internal to the Coherence Operator and a customer should not interact with it at all. The CoherenceInternal CRD is a representation of the values file used to install the Coherence Helm chart. The yaml for the CoherenceInternal CRD is in the file deploy/crds/coherence_v1_coherenceinternal_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceInternal struct in the pkg/apis/coherence/v1/coherenceinternal_types.go source file. ",
            "title": "Custom Resource Definitions (CRDs)"
        },
        {
            "location": "/developer/03_high_level",
            "text": " To modify the contents of a CRD (for example to add a new field) the corresponding Go struct needs to be updated. For backwards compatibility between released versions we should ensure that we do not delete fields. After any of the structs have been modified the new CRD files need to be generated, this is done by running the Operator SDK generator using the Makefile. If the generate step is not run the code will not work properly. <markup lang=\"bash\" >make generate ",
            "title": "Modifying CRDs"
        },
        {
            "location": "/developer/03_high_level",
            "text": " The Coherence Operator has been built using the Operator SDK and hence the design is based on how the framework works. Custom Resource Definitions (CRDs) In Kubernetes a CRD is a yaml (or json) file that defines the structure of a custom resource. When building operators using the Operator SDK the yaml files are not edited directly, they are generated from the Go structs in the source code. The Coherence Operator has three CRDs: CoherenceCluster CoherenceRole CoherenceInternal CoherenceCluster CRD The CoherenceCluster CRD is the main CRD that defines what a Coherence cluster looks like. This is the CRD that a customer creates and manges through the normal kubernetes commands and APIs. A CoherenceCluster is made up of one or more roles. Each role defines a sub-set of the members of a Coherence cluster (or all of the members in the case of a cluster with a single role). The yaml for the CoherenceCluster CRD is in the file deploy/crds/coherence_v1_coherencecluster_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceCluster struct in the pkg/apis/coherence/v1/coherencecluster_types.go source file. CoherenceRole CRD The CoherenceRole CRD is a definition of a role within a CoherenceCluster. A role is a sub-set of the members of a cluster that all share the same configuration. A customer should not interact directly with a CoherenceRole other than when scaling (for example using kubectl scale commands). The reason that a cluster is split into roles represented by a different CRD is to allow more fine grained control over different parts of the cluster, especially for operations such as scaling. By having a separate CRD for a role allows a customer to update or scale each role individually. The yaml for the CoherenceRole CRD is in the file deploy/crds/coherence_v1_coherencerole_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceRole struct in the pkg/apis/coherence/v1/coherencerole_types.go source file. CoherenceInternal CRD The CoherenceInternal CRD is (as the name suggests) entirely internal to the Coherence Operator and a customer should not interact with it at all. The CoherenceInternal CRD is a representation of the values file used to install the Coherence Helm chart. The yaml for the CoherenceInternal CRD is in the file deploy/crds/coherence_v1_coherenceinternal_crd.yaml . This yaml is generated by the Operator SDK from the CoherenceInternal struct in the pkg/apis/coherence/v1/coherenceinternal_types.go source file. Modifying CRDs To modify the contents of a CRD (for example to add a new field) the corresponding Go struct needs to be updated. For backwards compatibility between released versions we should ensure that we do not delete fields. After any of the structs have been modified the new CRD files need to be generated, this is done by running the Operator SDK generator using the Makefile. If the generate step is not run the code will not work properly. <markup lang=\"bash\" >make generate ",
            "title": "High Level Design"
        },
        {
            "location": "/developer/08_useful",
            "text": " For local testing, for example in Docker Desktop it is useful to add the zone label to your local K8s node with the fault domain that is then used by the Coherence Pods to set their site property. For example, if your local node is called docker-desktop you can use the following command to set the zone name to twilight-zone : <markup lang=\"bash\" >kubectl label node docker-desktop failure-domain.beta.kubernetes.io/zone=twilight-zone With this label set all Coherence Pods installed by the Coherence Operator on that node will be running in the twilight-zone . ",
            "title": "Labeling Your K8s Node"
        },
        {
            "location": "/developer/08_useful",
            "text": " Assuming that you have the Kubernetes Dashboard then you can easily start the local proxy and display the required login token by running: <markup lang=\"bash\" >./hack/kube-dash.sh This will display the authentication token, the local k8s dashboard URL and then start kubectl proxy . ",
            "title": "Kubernetes Dashboard"
        },
        {
            "location": "/developer/08_useful",
            "text": " Sometimes a CoherenceInternal resource becomes stuck in k8s. This is because the operator adds finalizers to the resources causing k8s to be unable to delete them. The simplest way to delete them is to use the kubectl patch command to remove the finalizer. For example, if there was a CoherenceInternal resource called test-role in namespace testing then the following command could be used. <markup lang=\"bash\" >kubectl -n testing patch coherenceinternal/test-role \\ -p '{\"metadata\":{\"finalizers\": []}}' \\ --type=merge; Alternatively there is a make target that wil clean up and remove all CoherenceCLuster, CoherenceRole and CoherenceInternal resources from the test namespace. <markup lang=\"bash\" >make delete-coherence-clusters ",
            "title": "Stuck CoherenceInternal Resources"
        },
        {
            "location": "/developer/08_useful",
            "text": " Labeling Your K8s Node For local testing, for example in Docker Desktop it is useful to add the zone label to your local K8s node with the fault domain that is then used by the Coherence Pods to set their site property. For example, if your local node is called docker-desktop you can use the following command to set the zone name to twilight-zone : <markup lang=\"bash\" >kubectl label node docker-desktop failure-domain.beta.kubernetes.io/zone=twilight-zone With this label set all Coherence Pods installed by the Coherence Operator on that node will be running in the twilight-zone . Kubernetes Dashboard Assuming that you have the Kubernetes Dashboard then you can easily start the local proxy and display the required login token by running: <markup lang=\"bash\" >./hack/kube-dash.sh This will display the authentication token, the local k8s dashboard URL and then start kubectl proxy . Stuck CoherenceInternal Resources Sometimes a CoherenceInternal resource becomes stuck in k8s. This is because the operator adds finalizers to the resources causing k8s to be unable to delete them. The simplest way to delete them is to use the kubectl patch command to remove the finalizer. For example, if there was a CoherenceInternal resource called test-role in namespace testing then the following command could be used. <markup lang=\"bash\" >kubectl -n testing patch coherenceinternal/test-role \\ -p '{\"metadata\":{\"finalizers\": []}}' \\ --type=merge; Alternatively there is a make target that wil clean up and remove all CoherenceCLuster, CoherenceRole and CoherenceInternal resources from the test namespace. <markup lang=\"bash\" >make delete-coherence-clusters ",
            "title": "Useful Info"
        },
        {
            "location": "/guides/03_management",
            "text": " Coherence clusters can be deployed with a ReST management endpoint enabled. ",
            "title": "preambule"
        },
        {
            "location": "/guides/03_management",
            "text": " TBD&#8230;&#8203; ",
            "title": "Deploying Coherence Clusters with Management"
        },
        {
            "location": "/developer/07_execution",
            "text": " NOTE: The Coherence Operator by default runs in and monitors a single namespace. This is different behaviour to v1.0 of the Coherence Operator. For more details see the Operator SDK document on Operator Scope . ",
            "title": "Namespaces"
        },
        {
            "location": "/developer/07_execution",
            "text": " To stop the local operator just use CTRL-Z or CTRL-C. Sometimes processes can be left around even after exiting in this way. To make sure all of the processes are dead you can run the kill script: <markup lang=\"bash\" >./hack/kill-local.sh ",
            "title": "Stopping the Local Operator"
        },
        {
            "location": "/developer/07_execution",
            "text": " During development running the Coherence Operator locally is by far the simplest option as it is faster and it also allows remote debugging if you are using a suitable IDE. To run a local copy of the operator that will connect to whatever you local kubernetes config is pointing to: <markup lang=\"bash\" >make run Stopping the Local Operator To stop the local operator just use CTRL-Z or CTRL-C. Sometimes processes can be left around even after exiting in this way. To make sure all of the processes are dead you can run the kill script: <markup lang=\"bash\" >./hack/kill-local.sh ",
            "title": "Running Locally"
        },
        {
            "location": "/developer/07_execution",
            "text": " After running the operator the CRDs can be removed from the k8s cluster by running the make target: <markup lang=\"bash\" >make uninstall-crds ",
            "title": "Clean-up"
        },
        {
            "location": "/developer/07_execution",
            "text": " The simplest and most reliable way to deploy the operator to K8s is to use the Helm chart. After building the operator the chart is created in the build/_output/helm-charts/coherence-operator directory. Using the Helm chart will ensure that all of the required RBAC rules are created when deploying to an environment where RBAC is enabled. The chart can be installed in the usual way with Helm <markup lang=\"bash\" >helm install --name operator \\ --namespace operator-test \\ build/_output/helm-charts/coherence-operator ",
            "title": "Deploying to Kubernetes"
        },
        {
            "location": "/developer/07_execution",
            "text": " There are two ways to run the Coherence Operator, either deployed into a k8s cluster or by using the Operator SDK to run it locally on your dev machine (assuming your dev machine has access to a k8s cluster such as Docker Desktop on MacOS). Namespaces NOTE: The Coherence Operator by default runs in and monitors a single namespace. This is different behaviour to v1.0 of the Coherence Operator. For more details see the Operator SDK document on Operator Scope . Running Locally During development running the Coherence Operator locally is by far the simplest option as it is faster and it also allows remote debugging if you are using a suitable IDE. To run a local copy of the operator that will connect to whatever you local kubernetes config is pointing to: <markup lang=\"bash\" >make run Stopping the Local Operator To stop the local operator just use CTRL-Z or CTRL-C. Sometimes processes can be left around even after exiting in this way. To make sure all of the processes are dead you can run the kill script: <markup lang=\"bash\" >./hack/kill-local.sh Clean-up After running the operator the CRDs can be removed from the k8s cluster by running the make target: <markup lang=\"bash\" >make uninstall-crds Deploying to Kubernetes The simplest and most reliable way to deploy the operator to K8s is to use the Helm chart. After building the operator the chart is created in the build/_output/helm-charts/coherence-operator directory. Using the Helm chart will ensure that all of the required RBAC rules are created when deploying to an environment where RBAC is enabled. The chart can be installed in the usual way with Helm <markup lang=\"bash\" >helm install --name operator \\ --namespace operator-test \\ build/_output/helm-charts/coherence-operator ",
            "title": "Running Coherence Operator Development"
        },
        {
            "location": "/developer/01_introduction",
            "text": " The Coherence Operator is a Go based project built using the Operator SDK . ",
            "title": "preambule"
        },
        {
            "location": "/developer/01_introduction",
            "text": " The following prerequisites are required to build and test the operator (the prerequisites to just run the operator are obviously a sub-set of these). operator-sdk version v0.9.0 git go version v1.12+. mercurial version 3.9+ docker version 17.03+. kubectl version v1.11.3+. Access to a Kubernetes v1.11.3+ cluster. Java 8+ JDK Maven version 3.5+ Access to a Maven repository containing Oracle Coherence 12.2.1.4 (for the exact GAV see the pom.xml file in the java/ directory) Optional: delve version 1.2.0+ (for local debugging with operator-sdk up local --enable-delve ). This project uses make for building, which should already be installed on most systems This project currently uses the Operator SDK v0.9.0 so make sure you install the correct version of the Operator SDK CLI. As stated above this project requires K8s v1.11.3+ so if using Docker on MacOS you need at least version 2.1.0.0 ",
            "title": "Development Prerequisites"
        },
        {
            "location": "/developer/01_introduction",
            "text": " The project also contains a Java sub-project that is used to create Coherence utilities that the Operator relies on to work correctly with Coherence clusters that it is managing. This project was initially generated using the Operator SDK and this dictates the structure of the project which means that files and directories should not be moved arbitrarily. ",
            "title": "Project Structure"
        },
        {
            "location": "/developer/01_introduction",
            "text": " The following should not be moved: File Description bin/ scripts used in the Operator Docker image build/Dockerfile the Dockerfile used by the Operator SDK to build the Docker image cmd/manager/main.go The Operator main generated by the Operator SDK deploy/ Yaml files generated and maintained by the Operator SDK deploy/crds The CRD files generated and maintained by the Operator SDK helm-charts/ The Helm charts used by the Operator pkg/apis The API struct code generated by the Operator SDK and used to generate the CRD files pkg/controller The controller code generated by the Operator SDK watches.yaml The Helm Operator configuration generated by the Operator SDK local-watches.yaml The Helm Operator configuration used when running the operator locally ",
            "title": "Operator SDK Files"
        },
        {
            "location": "/developer/01_introduction",
            "text": " Development Prerequisites The following prerequisites are required to build and test the operator (the prerequisites to just run the operator are obviously a sub-set of these). operator-sdk version v0.9.0 git go version v1.12+. mercurial version 3.9+ docker version 17.03+. kubectl version v1.11.3+. Access to a Kubernetes v1.11.3+ cluster. Java 8+ JDK Maven version 3.5+ Access to a Maven repository containing Oracle Coherence 12.2.1.4 (for the exact GAV see the pom.xml file in the java/ directory) Optional: delve version 1.2.0+ (for local debugging with operator-sdk up local --enable-delve ). This project uses make for building, which should already be installed on most systems This project currently uses the Operator SDK v0.9.0 so make sure you install the correct version of the Operator SDK CLI. As stated above this project requires K8s v1.11.3+ so if using Docker on MacOS you need at least version 2.1.0.0 Project Structure The project also contains a Java sub-project that is used to create Coherence utilities that the Operator relies on to work correctly with Coherence clusters that it is managing. This project was initially generated using the Operator SDK and this dictates the structure of the project which means that files and directories should not be moved arbitrarily. Operator SDK Files The following should not be moved: File Description bin/ scripts used in the Operator Docker image build/Dockerfile the Dockerfile used by the Operator SDK to build the Docker image cmd/manager/main.go The Operator main generated by the Operator SDK deploy/ Yaml files generated and maintained by the Operator SDK deploy/crds The CRD files generated and maintained by the Operator SDK helm-charts/ The Helm charts used by the Operator pkg/apis The API struct code generated by the Operator SDK and used to generate the CRD files pkg/controller The controller code generated by the Operator SDK watches.yaml The Helm Operator configuration generated by the Operator SDK local-watches.yaml The Helm Operator configuration used when running the operator locally ",
            "title": "Coherence Operator Development"
        },
        {
            "location": "/about/01_overview",
            "text": " settings Install Installing and running the Coherence Operator. explore Guides Follow step-by-step guides to using the Coherence Operator to manage Coherence clusters. ",
            "title": "Get going"
        },
        {
            "location": "/about/01_overview",
            "text": " widgets Coherence Clusters In depth CoherenceCluster CRD documentation. build Developer Developer guide for building the Coherence Operator. ",
            "title": "In Depth"
        },
        {
            "location": "/install/02_prerequisites",
            "text": " Everything needed to install and run the Coherence Operator is listed below: ",
            "title": "preambule"
        },
        {
            "location": "/install/02_prerequisites",
            "text": " In order for the Coherence Operator to be able to install Coherence clusters it needs to be able to pull Coherence Docker images. These images are not available in public Docker repositories and will typically Kubernetes will need authentication to be able to pull them. This is achived by creating pull secrets. Pull secrets are not global and hence secrets will be required in the namespace(s) that Coherence clusters will be installed into. ",
            "title": "Image Pull Secrets"
        },
        {
            "location": "/install/02_prerequisites",
            "text": " Access to a Kubernetes v1.11.3+ cluster. Access to Oracle Coherence Docker images. Image Pull Secrets In order for the Coherence Operator to be able to install Coherence clusters it needs to be able to pull Coherence Docker images. These images are not available in public Docker repositories and will typically Kubernetes will need authentication to be able to pull them. This is achived by creating pull secrets. Pull secrets are not global and hence secrets will be required in the namespace(s) that Coherence clusters will be installed into. ",
            "title": "Prerequisites"
        },
        {
            "location": "/developer/04_how_it_works",
            "text": " In the Operator SDK framework a controller is responsible for managing a specific CRD. A single controller could, in theory, manage multiple CRDs but it is clearer and simpler to keep them separate. The Coherence Operator has three controllers, two are part of the operator source code and one is provided by the Operator SDK framework. All controllers have a Reconcile function that is triggered by events from Kubernetes for resources that the controller is listening to. ",
            "title": "Controllers"
        },
        {
            "location": "/developer/04_how_it_works",
            "text": " The CoherenceCluster controller manages instances of the CoherenceCluster CRD. The source for this controller is in the pkg/controller/coherencecluster/coherencecluster_controller.go file. The CoherenceCluster controller listens for events related to CoherenceCluster CRDs created or modified in the namespace that the operator is running in. It also listens to events for any CoherenceRole CRD that it owns. When a CoherenceCluster resource is created or modified a CoherenceRole is created (or modified or deleted) for each role in the CoherenceCluster spec. Each time a k8s event is raised for a CoherenceCluster or CoherenceRole resource the Reconcile method on the CoherenceCluster controller is called. Create - When a CoherenceCluster is created the controller will work out how many roles are present in the spec. For each role that has a Replica count greater than zero a CoherenceRole is created in k8s. When a CoherenceRole is created it is associated to the parent CoherenceCluster so that k8s can track ownership of related resources (this is used for cascade delete - see below). Update - When a CoherenceCluster is updated the controller will work out what the roles in the updated spec should be. It then compares these roles to the currently deployed CoherenceRoles for that cluster. It then creates, updates or deletes CoherenceRoles as required. Delete - When a CoherenceCluster is deleted the controller does not currently need to do anything. This is because k8s has cascade delete functionality that allows related resources to be deleted together (a little like cascade delete in a database). When a CoherenceCluster is deleted then any related CoherenceRoles will be deleted and also any resources that have those CoherenceRoles as owners (i.e. the corresponding CoherenceInternal resources) ",
            "title": "CoherenceCluster Controller"
        },
        {
            "location": "/developer/04_how_it_works",
            "text": " The CoherenceRole controller manages instances of the CoherenceRole CRD. The source for this controller is in the pkg/controller/coherencerole/coherencerole_controller.go file. The CoherenceRole controller listens for events related to CoherenceRole CRDs created or modified in the namespace that the operator is running in. It also listens to events for any StatefulSet resources that were created by the corresponding Helm install for the role. When a CoherenceRole resource is created or modified a corresponding CoherenceInternal resource is created (or modified or deleted) from the role&#8217;s spec. Creation of a CoherenceInternal resource will trigger a Helm install of the Coherence Helm chart by the Helm Controller. Each time a k8s event is raised for a CoherenceRole or for a StatefulSet resource related to the role the Reconcile method on the CoherenceRole controller is called. The StatefulSet resource is listened to as a way to keep track of the state fo the role, i.e how many replicas are actually running and ready compared to the desired state. The StatefulSet is also used to obtain references to the Pods that make up the role when performing a StatusHA check prior to scaling. Create - When a CoherenceRole is created a corresponding CoherenceInternal resource will be created in k8s. Update - When a CoherenceRole is updated one of three actions can take place. Scale Up - If the update increases the role&#8217;s replica count then the role is being scaled up. The role&#8217;s spec is first checked to determine whether anything else has changed, if it has a rolling upgrade is performed first to bring the existing members up to the desired spec. After any possible the upgrade then the role&#8217;s member count is scaled up. Scale Down - If the update decreases the role&#8217;s replica count then the role is being scaled down. The member count of the role is scaled down and then the role&#8217;s spec is checked to determine whether anything else has changed, if it has a rolling upgrade is performed to bring the remaining members up to the desired spec. Update Only - If the changes to the role&#8217;s spec do not include a change to the replica count then a rolling upgrade is performed of the existing cluster members. Rolling Upgrade - A rolling upgrade is actually performed out of the box by the StatefulSet associated to the role. To upgrade the members of a role the CoherenceRole controller only has to update the CoherenceInternal spec. This will cause the Helm controller to update the associated Helm install whivh in turn causes the StatefulSet to perform a rolling update of the associated Pods. Scaling - The CoherenceOperator supports safe scaling of the members of a role. This means that a scaling operation will not take place unless the members of the role are Status HA. Safe scaling means that the number of replicas is scaled one at a time untile the desired size is reached with a Status HA check being performed before each member is added or removed. The exact action is controlled by a customer defined scaling policy that is part of the role&#8217;s spec. There are three policy types: SafeScaling - the safe scaling policy means that regardless of whether a role is being scaled up or down the size is always scaled one at a time with a Status HA check before each member is added or removed. ParallelScaling - with parallel scaling no Status HA check is performed, a role is scaled to the desired size by adding or removing the required number of members at the same time. For a storage enabled role with this policy scaling down could result in data loss. Ths policy is intended for storage disabled roles where it allows for fatser start and scaling times. ParallelUpSafeDownScaling - this policy is the default scaling policy. It means that when scaling up the required number of members is added all at once but when scaling down members are removed one at a time with a Status HA check before each removal. This policy allows clusters to start and scale up fatser whilst protecting from data loss when scaling down. Delete - As with a CoherenceCluster, when a CoherenceRole is deleted its corresponding CoherenceInternal resource is also deleted by a cascading delete in k8s. The CoherenceRole controller does not need to take any action on deletion. ",
            "title": "CoherenceRole Controller"
        },
        {
            "location": "/developer/04_how_it_works",
            "text": " The final controller in the Coherence Operator is the Helm controller. This controller is actually part of the Operator SDK and the source is not in the Coherence Operator&#8217;s source code tree. The Helm controller is configured to watch for a particular CRD and performs Helm install, delete and upgrades as resources based on that CRD are created, deleted or updated. In the case of the Coherence Operator the Helm controller is watching for instances of the CoherenceInternal CRD that are created, updated or deleted by the CoherenceRole controller. When this occurs the Helm controller uses the spec of the CoherenceInternal resource as the values file to install or upgrade the Coherence Helm chart. The Coherence Helm chart used by the operator is actually embedded in the Coherence Operator Docker image so there is no requirement for the customer to have access to a chart repository. The Helm operator also uses an embedded helm and tiller so there is no requirement for the customer to install Helm in their k8s cluster. A customer can have Helm installed but it will never be used by the operator so there is no version conflict. If a customer were to perform a helm ls operation in their cluster they would not see the installs controlled by the Coherence Operator. ",
            "title": "Helm Controller"
        },
        {
            "location": "/developer/04_how_it_works",
            "text": " The high level operation of the Coherence Operator can be seen in the diagram below. The entry point to the operator is the`main()` function in the cmd/manager/main.go file. This function performs the creation and initialisation of the three controllers and the ReST server. It also creates a configuration k8s secret that is used by Coherence Pods. The Coherence Operator works in a single namespace, that is it manages CRDs and hence Coherence clusters only in the same namespace that it is installed into. Controllers In the Operator SDK framework a controller is responsible for managing a specific CRD. A single controller could, in theory, manage multiple CRDs but it is clearer and simpler to keep them separate. The Coherence Operator has three controllers, two are part of the operator source code and one is provided by the Operator SDK framework. All controllers have a Reconcile function that is triggered by events from Kubernetes for resources that the controller is listening to. CoherenceCluster Controller The CoherenceCluster controller manages instances of the CoherenceCluster CRD. The source for this controller is in the pkg/controller/coherencecluster/coherencecluster_controller.go file. The CoherenceCluster controller listens for events related to CoherenceCluster CRDs created or modified in the namespace that the operator is running in. It also listens to events for any CoherenceRole CRD that it owns. When a CoherenceCluster resource is created or modified a CoherenceRole is created (or modified or deleted) for each role in the CoherenceCluster spec. Each time a k8s event is raised for a CoherenceCluster or CoherenceRole resource the Reconcile method on the CoherenceCluster controller is called. Create - When a CoherenceCluster is created the controller will work out how many roles are present in the spec. For each role that has a Replica count greater than zero a CoherenceRole is created in k8s. When a CoherenceRole is created it is associated to the parent CoherenceCluster so that k8s can track ownership of related resources (this is used for cascade delete - see below). Update - When a CoherenceCluster is updated the controller will work out what the roles in the updated spec should be. It then compares these roles to the currently deployed CoherenceRoles for that cluster. It then creates, updates or deletes CoherenceRoles as required. Delete - When a CoherenceCluster is deleted the controller does not currently need to do anything. This is because k8s has cascade delete functionality that allows related resources to be deleted together (a little like cascade delete in a database). When a CoherenceCluster is deleted then any related CoherenceRoles will be deleted and also any resources that have those CoherenceRoles as owners (i.e. the corresponding CoherenceInternal resources) CoherenceRole Controller The CoherenceRole controller manages instances of the CoherenceRole CRD. The source for this controller is in the pkg/controller/coherencerole/coherencerole_controller.go file. The CoherenceRole controller listens for events related to CoherenceRole CRDs created or modified in the namespace that the operator is running in. It also listens to events for any StatefulSet resources that were created by the corresponding Helm install for the role. When a CoherenceRole resource is created or modified a corresponding CoherenceInternal resource is created (or modified or deleted) from the role&#8217;s spec. Creation of a CoherenceInternal resource will trigger a Helm install of the Coherence Helm chart by the Helm Controller. Each time a k8s event is raised for a CoherenceRole or for a StatefulSet resource related to the role the Reconcile method on the CoherenceRole controller is called. The StatefulSet resource is listened to as a way to keep track of the state fo the role, i.e how many replicas are actually running and ready compared to the desired state. The StatefulSet is also used to obtain references to the Pods that make up the role when performing a StatusHA check prior to scaling. Create - When a CoherenceRole is created a corresponding CoherenceInternal resource will be created in k8s. Update - When a CoherenceRole is updated one of three actions can take place. Scale Up - If the update increases the role&#8217;s replica count then the role is being scaled up. The role&#8217;s spec is first checked to determine whether anything else has changed, if it has a rolling upgrade is performed first to bring the existing members up to the desired spec. After any possible the upgrade then the role&#8217;s member count is scaled up. Scale Down - If the update decreases the role&#8217;s replica count then the role is being scaled down. The member count of the role is scaled down and then the role&#8217;s spec is checked to determine whether anything else has changed, if it has a rolling upgrade is performed to bring the remaining members up to the desired spec. Update Only - If the changes to the role&#8217;s spec do not include a change to the replica count then a rolling upgrade is performed of the existing cluster members. Rolling Upgrade - A rolling upgrade is actually performed out of the box by the StatefulSet associated to the role. To upgrade the members of a role the CoherenceRole controller only has to update the CoherenceInternal spec. This will cause the Helm controller to update the associated Helm install whivh in turn causes the StatefulSet to perform a rolling update of the associated Pods. Scaling - The CoherenceOperator supports safe scaling of the members of a role. This means that a scaling operation will not take place unless the members of the role are Status HA. Safe scaling means that the number of replicas is scaled one at a time untile the desired size is reached with a Status HA check being performed before each member is added or removed. The exact action is controlled by a customer defined scaling policy that is part of the role&#8217;s spec. There are three policy types: SafeScaling - the safe scaling policy means that regardless of whether a role is being scaled up or down the size is always scaled one at a time with a Status HA check before each member is added or removed. ParallelScaling - with parallel scaling no Status HA check is performed, a role is scaled to the desired size by adding or removing the required number of members at the same time. For a storage enabled role with this policy scaling down could result in data loss. Ths policy is intended for storage disabled roles where it allows for fatser start and scaling times. ParallelUpSafeDownScaling - this policy is the default scaling policy. It means that when scaling up the required number of members is added all at once but when scaling down members are removed one at a time with a Status HA check before each removal. This policy allows clusters to start and scale up fatser whilst protecting from data loss when scaling down. Delete - As with a CoherenceCluster, when a CoherenceRole is deleted its corresponding CoherenceInternal resource is also deleted by a cascading delete in k8s. The CoherenceRole controller does not need to take any action on deletion. Helm Controller The final controller in the Coherence Operator is the Helm controller. This controller is actually part of the Operator SDK and the source is not in the Coherence Operator&#8217;s source code tree. The Helm controller is configured to watch for a particular CRD and performs Helm install, delete and upgrades as resources based on that CRD are created, deleted or updated. In the case of the Coherence Operator the Helm controller is watching for instances of the CoherenceInternal CRD that are created, updated or deleted by the CoherenceRole controller. When this occurs the Helm controller uses the spec of the CoherenceInternal resource as the values file to install or upgrade the Coherence Helm chart. The Coherence Helm chart used by the operator is actually embedded in the Coherence Operator Docker image so there is no requirement for the customer to have access to a chart repository. The Helm operator also uses an embedded helm and tiller so there is no requirement for the customer to install Helm in their k8s cluster. A customer can have Helm installed but it will never be used by the operator so there is no version conflict. If a customer were to perform a helm ls operation in their cluster they would not see the installs controlled by the Coherence Operator. ",
            "title": "How The Operator Works"
        },
        {
            "location": "/developer/05_building",
            "text": " The Operator SDK generates Go projects that use Go Modules and hence the Coherence Operator uses Go Modules too. The Coherence Operator can be checked out from Git to any location, it does not have to be under your $GOPATH . The first time that the project is built may require Go to fetch a number of dependencies and may take longer than usual to complete. The easiest way to build the whole project is using make . To build the Coherence Operator, package the Helm charts and create the various Docker images run the following command: <markup lang=\"bash\" >make build-all-images The build-all-images make target will build the Go and Java parts of the Operator and create all of the images required. ",
            "title": "How to Build the Coherence Operator"
        },
        {
            "location": "/developer/05_building",
            "text": " The Coherence Operator contains tests that can be executed using make . The tests are plain Go tests and also Ginkgo test suites. To execute the unit and functional tests that do not require a k8s cluster you can execute the following command: <markup lang=\"bash\" >make test-all This will build and execute all of the Go and Java tests, you do not need to have run a make build first. ",
            "title": "Unit Tests"
        },
        {
            "location": "/developer/05_building",
            "text": " To only tun the Go tests use: <markup lang=\"bash\" >make test-operator ",
            "title": "Go Unit Tests"
        },
        {
            "location": "/developer/05_building",
            "text": " To only tun the Java tests use: <markup lang=\"bash\" >make test-mvn ",
            "title": "Java Unit Tests"
        },
        {
            "location": "/developer/05_building",
            "text": " End to end tests require the Operator to be running. There are three types of end-to-end tests, Helm tests, local tests and remote tests. Helm tests are tests that install the Coherence Operator Helm chart and then make assertions about the state fo the resulting install. These tests do not test functionality of the Operator itself. The Helm tests suite is run using make: make helm-test Local tests, which is the majority ot the tests, can be executed with a locally running operator (i.e. the operator does not need to be deployed in a container in k8s). This makes the tests faster to run and also makes it possible to run the operator in a debugger while the test is executing The local end-to-end test suite is run using make: make e2e-local-test It is possible to run a sub-set of the tests or an individual test by using the GO_TEST_FLAGS=&lt;regex&gt; parameter. For example, to just run the TestMinimalCoherenceCluster clustering test in the test/e2e/local/clustering_test.go file: <markup lang=\"bash\" >make e2e-local-test GO_TEST_FLAGS='-run=^TestMinimalCoherenceCluster$$' The reg-ex above matches exactly the TestMinimalCoherenceCluster test name because it uses the reg-ex start ^ and end $ characters. For example, to run all of the clustering tests where the test name starts with TestOneRole we can use the reg-ex ^TestOneRole.*' <markup lang=\"bash\" >make e2e-local-test GO_TEST_FLAGS='-run=^TestOneRole.*' Note Any $ signs in the reg-ex need to be escaped by using a double dollar sign $$ . The GO_TEST_FLAGS parameter can actually consist of any valid argument to be passed to the go test command. There is plenty of documentation on go test Remote tests require the operator to actually be installed in a container in k8s. An example of this is the scaling tests because the operator needs to be able to directly reach the Pods. Very few end-to-end tests fall into this categrory. The local end-to-end test suite is run using make: make e2e-test As with local tests the GO_TEST_FLAGS parameter can be used to execute a sub-set of tests or a single test. ",
            "title": "End-to-End Tests"
        },
        {
            "location": "/developer/05_building",
            "text": " Unit Tests The Coherence Operator contains tests that can be executed using make . The tests are plain Go tests and also Ginkgo test suites. To execute the unit and functional tests that do not require a k8s cluster you can execute the following command: <markup lang=\"bash\" >make test-all This will build and execute all of the Go and Java tests, you do not need to have run a make build first. Go Unit Tests To only tun the Go tests use: <markup lang=\"bash\" >make test-operator Java Unit Tests To only tun the Java tests use: <markup lang=\"bash\" >make test-mvn End-to-End Tests End to end tests require the Operator to be running. There are three types of end-to-end tests, Helm tests, local tests and remote tests. Helm tests are tests that install the Coherence Operator Helm chart and then make assertions about the state fo the resulting install. These tests do not test functionality of the Operator itself. The Helm tests suite is run using make: make helm-test Local tests, which is the majority ot the tests, can be executed with a locally running operator (i.e. the operator does not need to be deployed in a container in k8s). This makes the tests faster to run and also makes it possible to run the operator in a debugger while the test is executing The local end-to-end test suite is run using make: make e2e-local-test It is possible to run a sub-set of the tests or an individual test by using the GO_TEST_FLAGS=&lt;regex&gt; parameter. For example, to just run the TestMinimalCoherenceCluster clustering test in the test/e2e/local/clustering_test.go file: <markup lang=\"bash\" >make e2e-local-test GO_TEST_FLAGS='-run=^TestMinimalCoherenceCluster$$' The reg-ex above matches exactly the TestMinimalCoherenceCluster test name because it uses the reg-ex start ^ and end $ characters. For example, to run all of the clustering tests where the test name starts with TestOneRole we can use the reg-ex ^TestOneRole.*' <markup lang=\"bash\" >make e2e-local-test GO_TEST_FLAGS='-run=^TestOneRole.*' Note Any $ signs in the reg-ex need to be escaped by using a double dollar sign $$ . The GO_TEST_FLAGS parameter can actually consist of any valid argument to be passed to the go test command. There is plenty of documentation on go test Remote tests require the operator to actually be installed in a container in k8s. An example of this is the scaling tests because the operator needs to be able to directly reach the Pods. Very few end-to-end tests fall into this categrory. The local end-to-end test suite is run using make: make e2e-test As with local tests the GO_TEST_FLAGS parameter can be used to execute a sub-set of tests or a single test. ",
            "title": "Testing"
        },
        {
            "location": "/developer/05_building",
            "text": " By default the version number used to tag the Docker images and Helm charts is set in the VERSION property in the Makefile and in the pom.xml files in the java/ directory. The Makefile also contains a VERSION_SUFFIX variable that is used to add a suffix to the build. By default this suffix is ci so the default version of the build artifacts is 2.0.0-ci . Change this suffix, for example when building a release candidate or a full release. For example, if building a release called alpha2 the following command can be used: <markup lang=\"bash\" >make build-all-images VERSION_SUFFIX=alpha2 If building a full release without a suffix the following command can be used <markup lang=\"bash\" >make build-all-images VERSION_SUFFIX=\"\" Testing Unit Tests The Coherence Operator contains tests that can be executed using make . The tests are plain Go tests and also Ginkgo test suites. To execute the unit and functional tests that do not require a k8s cluster you can execute the following command: <markup lang=\"bash\" >make test-all This will build and execute all of the Go and Java tests, you do not need to have run a make build first. Go Unit Tests To only tun the Go tests use: <markup lang=\"bash\" >make test-operator Java Unit Tests To only tun the Java tests use: <markup lang=\"bash\" >make test-mvn End-to-End Tests End to end tests require the Operator to be running. There are three types of end-to-end tests, Helm tests, local tests and remote tests. Helm tests are tests that install the Coherence Operator Helm chart and then make assertions about the state fo the resulting install. These tests do not test functionality of the Operator itself. The Helm tests suite is run using make: make helm-test Local tests, which is the majority ot the tests, can be executed with a locally running operator (i.e. the operator does not need to be deployed in a container in k8s). This makes the tests faster to run and also makes it possible to run the operator in a debugger while the test is executing The local end-to-end test suite is run using make: make e2e-local-test It is possible to run a sub-set of the tests or an individual test by using the GO_TEST_FLAGS=&lt;regex&gt; parameter. For example, to just run the TestMinimalCoherenceCluster clustering test in the test/e2e/local/clustering_test.go file: <markup lang=\"bash\" >make e2e-local-test GO_TEST_FLAGS='-run=^TestMinimalCoherenceCluster$$' The reg-ex above matches exactly the TestMinimalCoherenceCluster test name because it uses the reg-ex start ^ and end $ characters. For example, to run all of the clustering tests where the test name starts with TestOneRole we can use the reg-ex ^TestOneRole.*' <markup lang=\"bash\" >make e2e-local-test GO_TEST_FLAGS='-run=^TestOneRole.*' Note Any $ signs in the reg-ex need to be escaped by using a double dollar sign $$ . The GO_TEST_FLAGS parameter can actually consist of any valid argument to be passed to the go test command. There is plenty of documentation on go test Remote tests require the operator to actually be installed in a container in k8s. An example of this is the scaling tests because the operator needs to be able to directly reach the Pods. Very few end-to-end tests fall into this categrory. The local end-to-end test suite is run using make: make e2e-test As with local tests the GO_TEST_FLAGS parameter can be used to execute a sub-set of tests or a single test. ",
            "title": "Build Versions"
        },
        {
            "location": "/install/01_introduction",
            "text": " The Coherence Operator is available as a Docker image oracle/coherence-operator:2.0.0-1909131928 that can easily be installed into a Kubernetes cluster. ",
            "title": "preambule"
        },
        {
            "location": "/install/01_introduction",
            "text": " There are two ways to install the Coherence Operator Using Helm using the Coherence Operator Helm chart Manually using Kubernetes APIs (e.g. kubectl ) ",
            "title": "Installation Options"
        },
        {
            "location": "/guides/05_logging",
            "text": " Coherence clusters logs can be captured with ELK (or more accurately EFK) using Elasticsearch, Fluentd and Kibana. ",
            "title": "preambule"
        },
        {
            "location": "/guides/05_logging",
            "text": " TBD&#8230;&#8203; ",
            "title": "Capturing Coherence Cluster Logs"
        },
        {
            "location": "/install/04_manual_install",
            "text": " It is possible to install the Coherence Operator by crating the required yaml manually and installing it into Kubernetes. ",
            "title": "preambule"
        },
        {
            "location": "/install/04_manual_install",
            "text": " In Kubernetes clusters with RBAC enabled the Coherence Operator requires certain RBAC resources to be created. <markup lang=\"bash\" >sh examples/create_role.sh The example RBAC script creates a ServiceAccount with the name coherence-operator if a different name is required then the name in the example/example-rbac.yaml should be modified. The shell script above will use default values for the role name, role binding name and install into the default namespace. If the default values need to be changed or the operator is to be installed into a namespace other than default the script can be run with the following environment variables: <markup lang=\"bash\" >export ROLE_NAME=&lt;role-name&gt; export ROLE_BINDING_NAME=&lt;role-binding-name&gt; export NAMESPACE=&lt;namespace&gt; sh example/create_role.sh ",
            "title": "RBAC"
        },
        {
            "location": "/install/04_manual_install",
            "text": " Create a Deployment for the Coherence Operator using the example script. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; create -f example/example-deployment.yaml where &lt;namespace&gt; is the name of the namespace that the operator is to be deployed into. If RBAC is being used this will also be the same namespace used to create the RBAC roles. If the default namespace is being used the -n &lt;namespace&gt; argument can be omitted. ",
            "title": "Deployment"
        },
        {
            "location": "/about/03_kubernetes",
            "text": " For development and testing of the Coherence Operator it&#8217;s often convenient to run Kubernetes on your desktop. Two popular ways to do this are with Kubernetes Minikube or Kubernetes support in Docker for Desktop . In this guide we&#8217;ll use Docker for Desktop. ",
            "title": "preambule"
        },
        {
            "location": "/about/03_kubernetes",
            "text": " Install Docker for Mac or Docker for Windows . Starting with version 18.06 Docker for Desktop includes Kubernetes support. ",
            "title": "Install"
        },
        {
            "location": "/about/03_kubernetes",
            "text": " Enable Kubernetes Support for Mac or Kubernetes Support for Windows . Once Kubernetes installation is complete, make sure you have your context set correctly to use docker-for-desktop. <markup lang=\"bash\" title=\"Make sure K8s context is set to docker-for-desktop\" >kubectl config get-contexts kubectl config use-context docker-for-desktop kubectl cluster-info kubectl version --short kubectl get nodes ",
            "title": "Enable Kubernetes Support"
        },
        {
            "location": "/guides/01_overview",
            "text": " Quickstart Installing and running the Coherence Operator. Install Follow step-by-step guides to using the Coherence Operator to manage Coherence clusters. ",
            "title": "Getting Started"
        },
        {
            "location": "/guides/01_overview",
            "text": " ReST Management API Managing Coherence clusters with management over ReST. Coherence Metrics Publishing metrics from Coherence clusters. Clusters Managing Coherence clusters. Developer Developer guide for building the Coherence Operator. ",
            "title": "More Guides"
        },
        {
            "location": "/about/02_concepts",
            "text": " The Coherence Operator is a Kubernetes Operator that is used to manage Oracle Coherence clusters in Kubernetes. The Coherence Operator takes on the tasks of that human Dev Ops resource might carry out when managing Coherence clusters, such as configuration, installation, safe scaling, management and metrics. The Coherence Operator is a Go based application built using the Operator SDK . It is distributed as a Docker image and Helm chart for easy installation and configuration. ",
            "title": "What is the Coherence Operator"
        },
        {
            "location": "/about/02_concepts",
            "text": " Traditionally a Coherence cluster is a number of distributed JVMs that communicate to form a single coherent cluster. In Kubernetes this concept still applies but can now be though of as a number of Pods that form a single cluster. Inside each Pod is a JVM running Coherence, or some custom application using Coherence. The Coherence Operator uses a Kubernetes Custom Resource Definition to represent a Coherence cluster (and the roles withing it, see below). Every field in the CoherenceCluster crd Spec is optional so a cluster can be defined by yaml as simple as this: <markup lang=\"yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: my-cluster The metadata.name field in the CoherenceCluster will be used as the Coherence cluster name and would obviously be unique in a given k8s namespace. The Coherence Operator will use default values for fields that have not been entered, so the above yaml will create a Coherence cluster made up of a StatefulSet with a replica count of 3, so there will be three storage enabled Coherence Pods . ",
            "title": "Coherence Clusters"
        },
        {
            "location": "/about/02_concepts",
            "text": " A Coherence cluster can be made up of a number of Pods that perform different roles. All of the Pods in a given role share the same configuration. At a bare minimum a cluster would have at least one role where Pods are storage enabled. Each role in a Coherence cluster has a name and configuration. A cluster can have zero or many roles defined in the CoherenceCluster crd Spec . It is possible to define common configuration shared by all roles to save duplicating configuration multiple times in the yaml. The Coherence Operator will create a StatefulSet for each role defined in the CoherenceCluster crd yaml. This separation allows roles to be managed and scaled independently from each other. As described above the minimal yaml to define a CoherenceCluster is: <markup lang=\"yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: my-cluster Although there are no roles described in this yaml the Coherence Operator will create a default role with the name storage and give it a replica count of three. There are two ways to describe the specification of a role in a CoherenceCluster crd depending on whether the cluster created will have a single role or multiple roles. The same configuration to create a single role three member cluster as the minimal yaml could be specified more fully as follows: <markup lang=\"yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: my-cluster spec: role: storage replicas: 3 The role field specifies the name of the role, in this case stroage . The replicas field defines the number of Pods that will be started for this role, in this case three. If a cluster will have multiple roles they are defined in the spec.roles list; so again the same cluster could be defined more fully as: <markup lang=\"yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: my-cluster spec: roles: - role: storage replicas: 3 This time the role is defined in the roles section of the yaml. The roles section is a list of one or more role specifications. Multiple roles can be defined by adding more roles with distinct names to the roles list; for example: <markup lang=\"yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: my-cluster spec: roles: - role: storage replicas: 3 - role: web replicas: 2 In this case there are two roles defined, the first names storage , with three replicas and the second named web with two replicas. This will result in a Coherence cluster with a total of five members. The Coherence Operator would create two StatefulSets , one for storage with three Pods and one for web with two Pods . ",
            "title": "Coherence Roles"
        },
        {
            "location": "/guides/04_metrics",
            "text": " Coherence clusters can be deployed with a metrics endpoint enabled that can be scraped by common metrics applications such as Prometheus. ",
            "title": "preambule"
        },
        {
            "location": "/guides/04_metrics",
            "text": " To enable Prometheus, add the following options to the Operator Helm install command: <markup lang=\"bash\" >--set prometheusoperator.enabled=true --set prometheusoperator.prometheusOperator.createCustomResource=false A more complete helm install command to enable Prometheus is as follows: <markup lang=\"bash\" >helm install \\ --namespace &lt;namespace&gt; \\ --name coherence-operator \\ --set prometheusoperator.enabled=true \\ --set prometheusoperator.prometheusOperator.createCustomResource=false \\ coherence/coherence-operator Set &lt;namespace&gt; to the Kubernetes namespace that the Coherence Operator should be installed into. After the installation completes, list the pods in the namespace that the Operator was installed into: <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get pods The results returned should look something like the following: <markup lang=\"bash\" >NAME READY STATUS RESTARTS AGE operator-coherence-operator-5d779ffc7-7xz7j 1/1 Running 0 53s operator-grafana-9d7fc9486-46zb7 2/2 Running 0 53s operator-kube-state-metrics-7b4fcc5b74-ljdf8 1/1 Running 0 53s operator-prometheus-node-exporter-kwdr7 1/1 Running 0 53s operator-prometheusoperato-operator-77c784b8c5-v4bfz 1/1 Running 0 53s prometheus-operator-prometheusoperato-prometheus-0 3/3 Running 2 38s The Coherence Operator Pod The Grafana Pod The Prometheus Pod The demo install of Prometheus in the Operator configures Prometheus to use service monitors to work out which Pods to scrape metrics from. A ServiceMonitor in Prometheus will scrape from a port defined in a Kubernetes Service from all Pods that match that service&#8217;s selector. ",
            "title": "1. Install the Coherence Operator with Prometheus"
        },
        {
            "location": "/guides/04_metrics",
            "text": " Now that Prometheus is running Coherence clusters can be created that expose metrics on a port on each Pod and also deploy a Service to expose the metrics that Prometheus can use. Deploy a simple metrics enabled CoherenceCluster resource with a single role like this: <markup lang=\"yaml\" title=\"metrics-cluster.yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: test-cluster spec: role: storage replicas: 2 metrics: enabled: true ports: - name: metrics port: 9612 This cluster will have a single role called storage The cluster will have two replicas ( Pods ) The Coherence Pod spec contains a port spec for metrics named metric so this needs to be exposed as a service by specifying the metrics port in the role&#8217;s ports list The port must be set as 9612 which is the port that Coherence will expose metrics on The yaml above can be installed into Kubernetes using kubectl : <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; create -f metrics-cluster.yaml The Coherence Operator will see the new CoherenceCluster resource and create the cluster with two Pods . If kubectl get pods -n &lt;namespace&gt; is run again it should now look something like this: <markup lang=\"bash\" >NAME READY STATUS RESTARTS AGE operator-coherence-operator-5d779ffc7-7xz7j 1/1 Running 0 53s operator-grafana-9d7fc9486-46zb7 2/2 Running 0 53s operator-kube-state-metrics-7b4fcc5b74-ljdf8 1/1 Running 0 53s operator-prometheus-node-exporter-kwdr7 1/1 Running 0 53s operator-prometheusoperato-operator-77c784b8c5-v4bfz 1/1 Running 0 53s prometheus-operator-prometheusoperato-prometheus-0 3/3 Running 2 38s test-cluster-storage-0 1/1 Running 0 70s test-cluster-storage-1 1/1 Running 0 70s Pod one of the Coherence cluster. Pod two of the Coherence cluster. If the services are listed for the namespace: <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get svc The list of services will look something like this. <markup lang=\"bash\" >NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE operator-grafana ClusterIP 10.104.251.51 &lt;none&gt; 80/TCP 31m operator-kube-state-metrics ClusterIP 10.110.18.78 &lt;none&gt; 8080/TCP 31m operator-prometheus-node-exporter ClusterIP 10.102.181.6 &lt;none&gt; 9100/TCP 31m operator-prometheusoperato-operator ClusterIP 10.107.59.229 &lt;none&gt; 8080/TCP 31m operator-prometheusoperato-prometheus ClusterIP 10.99.208.18 &lt;none&gt; 9090/TCP 31m prometheus-operated ClusterIP None &lt;none&gt; 9090/TCP 31m test-cluster-storage-headless ClusterIP None &lt;none&gt; 30000/TCP 16m test-cluster-storage-metrics ClusterIP 10.109.201.211 &lt;none&gt; 9612/TCP 16m test-cluster-wka ClusterIP None &lt;none&gt; 30000/TCP 16m One of the services will be the service exposing the Coherence metrics. The service name is typically in the format &lt;cluster-name&gt;-&lt;role-name&gt;-&lt;port-name&gt; The Prometheus ServiceMonitor installed by the Coherence Operator is configured to look for services with the label component=coherence-service-metrics . When ports are exposed in a CoherenceCluster , as has been done here for metrics, the service created will have a label of the format component=coherence-service-&lt;port-name&gt; , so in this case the test-cluster-storage-metrics service above will have the label component=coherence-service-metrics . The labels for the service can be displayed: <markup lang=\"bash\" >kubectl -n &lt;namespace&gt;&gt; get svc/test-cluster-storage-metrics --label-columns=component <markup lang=\"bash\" >NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE COMPONENT test-cluster-storage-metrics ClusterIP 10.109.201.211 &lt;none&gt; 9612/TCP 26m coherence-service-metrics Which shows that the service does indeed have the required label. ",
            "title": "2. Install a Coherence Cluster with Metrics Enabled"
        },
        {
            "location": "/guides/04_metrics",
            "text": " Now that Prometheus is running and is able to scrape metrics from the Coherence cluster it should be possible to access those metrics in Prometheus. First find the Prometheus Pod name using kubectl <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get pod -l app=prometheus -o name Using the Pod name use kubectl to create a port forward session to the Prometheus Pod so that the Prometheus API on port 9090 in the Pod can be accessed from the local host. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; port-forward \\ $(kubectl -n &lt;namespace&gt; get pod -l app=prometheus -o name) \\ 9090:9090 It is now possible to access the Prometheus API on localhost port 9090. This can be used to directly retrieve Coherence metrics using curl , for example to obtain the cluster size metric: <markup lang=\"bash\" >curl -w '' -X GET http://127.0.0.1:9090/api/v1/query?query=vendor:coherence_cluster_size It is also possible to browse directly to the Prometheus web UI at http://127.0.0.1:9090 ",
            "title": "3. Access Prometheus"
        },
        {
            "location": "/guides/04_metrics",
            "text": " By default when the Coherence Operator configured to install Prometheus the Prometheus Operator also install a Grafana Pod and the Coherence Operator imports into Grafana a number of custom dashboards for displaying Coherence metrics. Grafana can be accessed by using port forwarding in the same way that was done for Prometheus First find the Grafana Pod : <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get pod -l app=grafana -o name Using the Pod name use kubectl to create a port forward session to the Grafana Pod so that the Grafana API on port 3000 in the Pod can be accessed from the local host. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; port-forward \\ $(kubectl -n &lt;namespace&gt; get pod -l app=grafana -o name) \\ 3000:3000 The custom Coherence dashboards can be accessed by pointing a browser to http://127.0.0.1:3000/d/coh-main/coherence-dashboard-main The Grafana credentials are username admin password prom-operator ",
            "title": "3. Access Grafana"
        },
        {
            "location": "/guides/04_metrics",
            "text": " After running the demo above the Coherence cluster can be removed using kubectl : <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; delete -f metrics-cluster.yaml The Coherence Operator, along with Prometheus and Grafana can be removed using Helm: <markup lang=\"bash\" >helm delete --purge coherence-operator ",
            "title": "4. Cleaning Up"
        },
        {
            "location": "/guides/04_metrics",
            "text": " Note: Use of metrics is available only when using the operator with clusters running Coherence 12.2.1.4 or later version. The Coherence Operator can be installed with a demo Prometheus installation using embedded Prometheus Operator and Grafana Helm charts. This Prometheus deployment is not intended for production use but is useful for development, testing and demo purposes. 1. Install the Coherence Operator with Prometheus To enable Prometheus, add the following options to the Operator Helm install command: <markup lang=\"bash\" >--set prometheusoperator.enabled=true --set prometheusoperator.prometheusOperator.createCustomResource=false A more complete helm install command to enable Prometheus is as follows: <markup lang=\"bash\" >helm install \\ --namespace &lt;namespace&gt; \\ --name coherence-operator \\ --set prometheusoperator.enabled=true \\ --set prometheusoperator.prometheusOperator.createCustomResource=false \\ coherence/coherence-operator Set &lt;namespace&gt; to the Kubernetes namespace that the Coherence Operator should be installed into. After the installation completes, list the pods in the namespace that the Operator was installed into: <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get pods The results returned should look something like the following: <markup lang=\"bash\" >NAME READY STATUS RESTARTS AGE operator-coherence-operator-5d779ffc7-7xz7j 1/1 Running 0 53s operator-grafana-9d7fc9486-46zb7 2/2 Running 0 53s operator-kube-state-metrics-7b4fcc5b74-ljdf8 1/1 Running 0 53s operator-prometheus-node-exporter-kwdr7 1/1 Running 0 53s operator-prometheusoperato-operator-77c784b8c5-v4bfz 1/1 Running 0 53s prometheus-operator-prometheusoperato-prometheus-0 3/3 Running 2 38s The Coherence Operator Pod The Grafana Pod The Prometheus Pod The demo install of Prometheus in the Operator configures Prometheus to use service monitors to work out which Pods to scrape metrics from. A ServiceMonitor in Prometheus will scrape from a port defined in a Kubernetes Service from all Pods that match that service&#8217;s selector. 2. Install a Coherence Cluster with Metrics Enabled Now that Prometheus is running Coherence clusters can be created that expose metrics on a port on each Pod and also deploy a Service to expose the metrics that Prometheus can use. Deploy a simple metrics enabled CoherenceCluster resource with a single role like this: <markup lang=\"yaml\" title=\"metrics-cluster.yaml\" >apiVersion: coherence.oracle.com/v1 kind: CoherenceCluster metadata: name: test-cluster spec: role: storage replicas: 2 metrics: enabled: true ports: - name: metrics port: 9612 This cluster will have a single role called storage The cluster will have two replicas ( Pods ) The Coherence Pod spec contains a port spec for metrics named metric so this needs to be exposed as a service by specifying the metrics port in the role&#8217;s ports list The port must be set as 9612 which is the port that Coherence will expose metrics on The yaml above can be installed into Kubernetes using kubectl : <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; create -f metrics-cluster.yaml The Coherence Operator will see the new CoherenceCluster resource and create the cluster with two Pods . If kubectl get pods -n &lt;namespace&gt; is run again it should now look something like this: <markup lang=\"bash\" >NAME READY STATUS RESTARTS AGE operator-coherence-operator-5d779ffc7-7xz7j 1/1 Running 0 53s operator-grafana-9d7fc9486-46zb7 2/2 Running 0 53s operator-kube-state-metrics-7b4fcc5b74-ljdf8 1/1 Running 0 53s operator-prometheus-node-exporter-kwdr7 1/1 Running 0 53s operator-prometheusoperato-operator-77c784b8c5-v4bfz 1/1 Running 0 53s prometheus-operator-prometheusoperato-prometheus-0 3/3 Running 2 38s test-cluster-storage-0 1/1 Running 0 70s test-cluster-storage-1 1/1 Running 0 70s Pod one of the Coherence cluster. Pod two of the Coherence cluster. If the services are listed for the namespace: <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get svc The list of services will look something like this. <markup lang=\"bash\" >NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE operator-grafana ClusterIP 10.104.251.51 &lt;none&gt; 80/TCP 31m operator-kube-state-metrics ClusterIP 10.110.18.78 &lt;none&gt; 8080/TCP 31m operator-prometheus-node-exporter ClusterIP 10.102.181.6 &lt;none&gt; 9100/TCP 31m operator-prometheusoperato-operator ClusterIP 10.107.59.229 &lt;none&gt; 8080/TCP 31m operator-prometheusoperato-prometheus ClusterIP 10.99.208.18 &lt;none&gt; 9090/TCP 31m prometheus-operated ClusterIP None &lt;none&gt; 9090/TCP 31m test-cluster-storage-headless ClusterIP None &lt;none&gt; 30000/TCP 16m test-cluster-storage-metrics ClusterIP 10.109.201.211 &lt;none&gt; 9612/TCP 16m test-cluster-wka ClusterIP None &lt;none&gt; 30000/TCP 16m One of the services will be the service exposing the Coherence metrics. The service name is typically in the format &lt;cluster-name&gt;-&lt;role-name&gt;-&lt;port-name&gt; The Prometheus ServiceMonitor installed by the Coherence Operator is configured to look for services with the label component=coherence-service-metrics . When ports are exposed in a CoherenceCluster , as has been done here for metrics, the service created will have a label of the format component=coherence-service-&lt;port-name&gt; , so in this case the test-cluster-storage-metrics service above will have the label component=coherence-service-metrics . The labels for the service can be displayed: <markup lang=\"bash\" >kubectl -n &lt;namespace&gt;&gt; get svc/test-cluster-storage-metrics --label-columns=component <markup lang=\"bash\" >NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE COMPONENT test-cluster-storage-metrics ClusterIP 10.109.201.211 &lt;none&gt; 9612/TCP 26m coherence-service-metrics Which shows that the service does indeed have the required label. 3. Access Prometheus Now that Prometheus is running and is able to scrape metrics from the Coherence cluster it should be possible to access those metrics in Prometheus. First find the Prometheus Pod name using kubectl <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get pod -l app=prometheus -o name Using the Pod name use kubectl to create a port forward session to the Prometheus Pod so that the Prometheus API on port 9090 in the Pod can be accessed from the local host. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; port-forward \\ $(kubectl -n &lt;namespace&gt; get pod -l app=prometheus -o name) \\ 9090:9090 It is now possible to access the Prometheus API on localhost port 9090. This can be used to directly retrieve Coherence metrics using curl , for example to obtain the cluster size metric: <markup lang=\"bash\" >curl -w '' -X GET http://127.0.0.1:9090/api/v1/query?query=vendor:coherence_cluster_size It is also possible to browse directly to the Prometheus web UI at http://127.0.0.1:9090 3. Access Grafana By default when the Coherence Operator configured to install Prometheus the Prometheus Operator also install a Grafana Pod and the Coherence Operator imports into Grafana a number of custom dashboards for displaying Coherence metrics. Grafana can be accessed by using port forwarding in the same way that was done for Prometheus First find the Grafana Pod : <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; get pod -l app=grafana -o name Using the Pod name use kubectl to create a port forward session to the Grafana Pod so that the Grafana API on port 3000 in the Pod can be accessed from the local host. <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; port-forward \\ $(kubectl -n &lt;namespace&gt; get pod -l app=grafana -o name) \\ 3000:3000 The custom Coherence dashboards can be accessed by pointing a browser to http://127.0.0.1:3000/d/coh-main/coherence-dashboard-main The Grafana credentials are username admin password prom-operator 4. Cleaning Up After running the demo above the Coherence cluster can be removed using kubectl : <markup lang=\"bash\" >kubectl -n &lt;namespace&gt; delete -f metrics-cluster.yaml The Coherence Operator, along with Prometheus and Grafana can be removed using Helm: <markup lang=\"bash\" >helm delete --purge coherence-operator ",
            "title": "Deploying Coherence Clusters with Metrics"
        }
 ]
}